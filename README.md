# Identify similar images

- 利用直方图距离计算图片相似度

计算公式：

<img src="http://chart.googleapis.com/chart?cht=tx&chl=Sim(G,S)=\frac{1}{N}\sum_{i=1}^{N}{(1-\frac{|g_i-s_i|}{Max(g_i,s_i)})}" style="border:none;">

其中，G和S为两张图片的图像颜色分布直方图，N为颜色空间样点数。

这里使用分块的方法计算相似度，用以提高各部分的特征，防止图片颜色相似导致计算的相似度高。

- 利用平均哈希算法计算图片相似度

计算步骤：

1. 缩放图片：一般大小为8*8，64个像素值
2. 简化色彩，转化为灰度图：可以使用Image的convert('L')方法
3. 计算平均值：计算出灰度图所有像素点的像素值的平均值
4. 比较像素灰度值：遍历灰度图的每一个像素值与上一步计算的平均值，大于平均值记录为1，否则为0
5. 得到64位图像指纹
6. 记录两张图片的图像指纹的汉明距离，计算图片相似度

- 利用感知哈希算法计算图片相似度

计算步骤：

1. 缩放图片：一般大小为32*32，这样方便DCT计算
2. 简化色彩，转化为灰度图：可以使用Image的convert('L')方法
3. 计算DCT（[离散余弦变换](https://en.wikipedia.org/wiki/Discrete_cosine_transform)）:
    > 获得图像的二维数据矩阵f(x,y)
    >
    > 求离散余弦变换的系数矩阵[A]
    >
    > 求系数矩阵对应的转置矩阵[A]T
    >
    > 根据公式[F(u,v)]=[A][f(x,y)][A]T 计算离散余弦变换

4. 缩小DCT：DCT计算后的矩阵是32\*32，保留左上角的8\*8，这些代表的图片的最低频率
5. 计算平均值：计算缩小DCT后的所有像素点的平均
6. 进一步减小DCT：大于平均值记录为1，否则为0
7. 得到64位信息指纹
8. 记录两张图片的图像指纹的汉明距离，计算图片相似度

- 利用差异哈希算法计算图片相似度

计算步骤：

1. 缩放图片：一般大小为9*8，以留下多一行的像素数据进行差异计算
2. 简化色彩，转化为灰度图：可以使用Image的convert('L')方法
3. 计算差异值：dHash算法工作在相邻像素之间，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异哈希值
4. 得到64位信息指纹：如果左边的像素比右边的更亮，则记录为1，否则为0
5. 记录两张图片的图像指纹的汉明距离，计算图片相似度

<br><br>

Use the related libraries:
>
> PIL
>
> matplotlib
